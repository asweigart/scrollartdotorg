<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proton Stream Scroll Art</title>
</head>
<body>

<textarea id="bextOutput" readonly style="height: calc(100vh - 40px); border: none;"></textarea><br />
<!--<input id="bextInput" readonly />-->
<button type="button" onclick="running = !running;">&#x23FB; Off</button>&nbsp;&nbsp;&nbsp;

<input type="text" id="foregroundColorSetting" style="width: 70px">
<input type="text" id="backgroundColorSetting" style="width: 70px">
<button type="button" onclick="changeColorTheme(document.getElementById('foregroundColorSetting').value, document.getElementById('backgroundColorSetting').value)">&#x1F197;</button>
<button type="button" onclick="swapColors();">&#x1F504;</button>&nbsp;&nbsp;&nbsp;&nbsp;

<button type="button" onclick="changeColorTheme('black', 'white');">&#x1F4A1;</button>
<button type="button" onclick="changeColorTheme('white', 'black');">&#x1F3B1;</button>
<button type="button" onclick="changeColorTheme('white', '#A10901');">&#x2764;&#xFE0F;</button>
<button type="button" onclick="changeColorTheme('#993D28', '#FCAF1B');">&#x1F36F;</button>
<button type="button" onclick="changeColorTheme('#E7B6BF', '#924C38');">&#x1FAB5;</button>
<button type="button" onclick="changeColorTheme('#F9F5D6', '#2E3672');">&#x1F327;&#xFE0F;</button>
<button type="button" onclick="changeColorTheme('#1B2463', '#00003E');">&#x1F311;</button>
<button type="button" onclick="changeColorTheme('#C2FA6F', '#554E80');">&#x1F9EA;</button>
<button type="button" onclick="changeColorTheme('#FFE082', '#1565C0');">&#x1F324;&#xFE0F;</button>
<button type="button" onclick="changeColorTheme('#00FF00', '#FF007F');">&#x1F349;</button>
<button type="button" onclick="changeColorTheme('#9CD54A', '#4A5A20');">&#x1F334;</button>


<script src="/static/bext.js"></script>
<link rel="stylesheet" href="/static/bext.css">


<script>

function setColorsBasedOnTextFields() {
    let fg = document.getElementById('foregroundColorSetting').value;
    let bg = document.getElementById('backgroundColorSetting').value;
    changeColorTheme(fg, bg);
}
document.addEventListener('DOMContentLoaded', (event) => {
document.getElementById('foregroundColorSetting').addEventListener('keydown', function(event) {
    // Check if the Enter key was pressed
    if (event.key === "Enter" || event.keyCode === 13) {
        // Prevent the default action to avoid form submission or any other default behavior
        event.preventDefault();
        setColorsBasedOnTextFields();
    }
});
document.getElementById('backgroundColorSetting').addEventListener('keydown', function(event) {
    // Check if the Enter key was pressed
    if (event.key === "Enter" || event.keyCode === 13) {
        // Prevent the default action to avoid form submission or any other default behavior
        event.preventDefault();
        setColorsBasedOnTextFields();
    }
});
});
function changeColorTheme(foregroundColor, backgroundColor) {
  document.body.style.backgroundColor = backgroundColor; 
  document.getElementById('bextOutput').style.backgroundColor = backgroundColor;
  document.getElementById('bextOutput').style.color = foregroundColor;
  document.getElementById('foregroundColorSetting').value = foregroundColor;
  document.getElementById('backgroundColorSetting').value = backgroundColor;
}

function swapColors() {
  let fg = document.getElementById('foregroundColorSetting').value;
  let bg = document.getElementById('backgroundColorSetting').value;
  changeColorTheme(bg, fg);
}


let bextRowBuffer = 256;  // Change this to whatever size you want, or -1 for infinite buffer.
let running = true;

// Constants for settings:
const DELAY = 10;  // Pause after each row in milliseconds.
const WIDTH = 60;  // Number of columns in output.
const NUM_STREAMS = 5;  // Number of streams on the screen.
const MAX_DISTANCE = NUM_STREAMS * 4;  // How many spaces streams must be within each other.
const MOVE_CHANCE = 0.75;  // How often a stream tries to move left or right, rather than continue straight.

const EMPTY_CHAR = ' ';
const STREAM_CHARS = 'oO@';

let streams = Array(NUM_STREAMS).fill(Math.floor(WIDTH / 2));


function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

(async function main() {
    while (running) {
        let columns = Array(WIDTH).fill(EMPTY_CHAR);

        streams.forEach((stream, i) => {
            if (Math.random() < MOVE_CHANCE) {
                // Move stream:
                if (Math.random() < 0.5) { // Adjusting for bias
                    if (stream > 0 && streams.every(other => Math.abs((stream - 1) - other) <= MAX_DISTANCE)) {
                        // Move stream left:
                        streams[i] -= 1;
                    }
                } else {
                    if (stream < WIDTH - 1 && streams.every(other => Math.abs((stream + 1) - other) <= MAX_DISTANCE)) {
                        // Move stream right:
                        streams[i] += 1;
                    }
                }
            }

            columns[stream] = STREAM_CHARS[i % STREAM_CHARS.length];
        });

        /*
        // Eh, sparks just don't make it look that good.
        // Add sparks:
        if (Math.random() < SPARK_CHANCE) {
            // Find range where sparks can appear:
            const leftmostSparkColumn = Math.max(0, Math.min(...streams) - SPARK_RANGE);
            const rightmostSparkColumn = Math.min(WIDTH - 1, Math.max(...streams) + SPARK_RANGE);

            // Add sparks:
            Array.from({length: randomNumSparks()}, () => Math.floor(Math.random() * (rightmostSparkColumn - leftmostSparkColumn + 1) + leftmostSparkColumn))
                 .forEach(x => {
                     if (!STREAM_CHARS.includes(columns[x])) {  // Don't overlap a stream with a spark
                         columns[x] = SPARK_CHARS[Math.floor(Math.random() * SPARK_CHARS.length)];
                     }
                 });
        }
        */

        print(columns.join(''));
        await sleep(DELAY);
    }
})();

</script>

</body>
</html>